public class Processor{    // Program Counter.    private Word PC = new Word();    // Stack Pointer.    private Word SP = new Word();    // Indicator for if the processor is halted.    private Bit halted = new Bit(false);    private Word currentInstruction = new Word();    // 31 registers plus 1 for the zero register.    private Word[] registers = new Word[32];    private Word rd, rs1, rs2, immediate, function;    private ALU alu = new ALU();    private int rdIndex = -1;    public Processor()    {        // Initializes other registers.        for (int i = 0; i < registers.length; i++)        {            registers[i] = new Word();            // Checks for register R0 and sets it to always be 0.            if (i == 0)            {                registers[i].set(0);            }        }        // Sets the beginning of memory (Starts at address 0).        PC.set(0);        // Sets the end of memory (Ends at address 1023 or the end of the 1024-word memory).        SP.set(1023);    }    public void run()    {        while (!halted.getValue())        {            fetch();            decode();            execute();            store();        }    }    private void fetch()    {        // Fetches instruction from memory.        currentInstruction.copy(MainMemory.read(PC));        // Increments PC to point to the next instruction.        PC.increment();    }    private void decode()    {        Word opcode = extractBits(currentInstruction, 27, 31);        // Resets or initialize words for storing extracted values.        rs1 = new Word();        rs2 = new Word();        rd = new Word();        immediate = new Word();        function = new Word();        rdIndex = -1;        int rdExtractedIndex;        int rs1Index;        int rs2Index;        // Extracts format from opcode (last 2 bits of opcode).        int format = (int)opcode.getUnsigned() & 0x3;        // Checks which instruction is acquired from the opcode.        switch (format)        {            case 0: // No R (0R).                immediate = extractBits(currentInstruction, 0, 26);                break;            case 1: // Dest Only (1R).                immediate = extractBits(currentInstruction, 0, 17);                function = extractBits(currentInstruction, 18, 21);                // Gets the index of the register.                rdExtractedIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();                // Uses the index to set rd to a copy of the destination register.                rd.copy(registers[rdExtractedIndex]);                rdIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();                break;            case 2: // 2 Register (2R).                immediate = extractBits(currentInstruction, 0, 12);                // Gets the index of the register.                rs1Index = (int)extractBits(currentInstruction, 13, 17).getUnsigned();                // Uses the index to set rs1 to a copy of the source register.                rs1.copy(registers[rs1Index]);                function = extractBits(currentInstruction, 18, 21);                // Gets the index of the register.                rdExtractedIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();                // Uses the index to set rd to a copy of the destination register.                rd.copy(registers[rdExtractedIndex]);                rdIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();                break;            case 3: // 3 Register (3R).                immediate = extractBits(currentInstruction, 0, 7);                // Gets the index of the register.                rs1Index = (int)extractBits(currentInstruction, 8, 12).getUnsigned();                // Uses the index to set rs1 to a copy of the source register.                rs1.copy(registers[rs1Index]);                // Gets the index of the register.                rs2Index = (int)extractBits(currentInstruction, 13, 17).getUnsigned();                // Uses the index to set rs2 to a copy of the source register.                rs2.copy(registers[rs2Index]);                function = extractBits(currentInstruction, 18, 21);                // Gets the index of the register.                rdExtractedIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();                // Uses the index to set rd to a copy of the destination register.                rd.copy(registers[rdExtractedIndex]);                rdIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();                break;            default:                throw new IllegalArgumentException("Invalid instruction format detected.");        }    }    // Helper method for decode to extract a subset of bits from an instruction for register representation.    private Word extractBits(Word instruction, int startBit, int endBit)    {        Word result = new Word();        for (int i = endBit, j = 31; i >= startBit; i--, j--)        {            Bit bit = instruction.getBit(i);            result.setBit(j, bit);        }        return result;    }    private void execute()    {        // Extracts opcode as a Word with the last 5 bits right-aligned.        Word opcodeWord = extractBits(currentInstruction, 27, 31);        // Checks the first bit of the opcode for 0.        if (opcodeWord.getBit(27).getValue() == false)        {            // Checks the second bit for 0.            if (opcodeWord.getBit(28).getValue() == false)            {                // Checks the third bit for 0.                if (opcodeWord.getBit(29).getValue() == false)                {                    // This is where the MATH operations will be handled.                    int format = ((opcodeWord.getBit(30).getValue() ? 2 : 0) + (opcodeWord.getBit(31).getValue() ? 1 : 0));                    // Prepares function bits for the ALU.                    Bit[] functionBits = new Bit[4];                    for (int i = 0; i < 4; i++) {                        functionBits[i] = function.getBit(28 + i);                    }                    // Switch case to pick which function to perform.                    switch (format)                    {                        case 0:                            // Half function.                            halted.set(true);                            return;                        case 1:                            // Copies the immediate value into rd for storage.                            rd.copy(immediate);                            break;                        case 2:                            // Performs operation on rd and rs1 (2R), then store result in rd.                            alu.op1.copy(rd);                            alu.op2.copy(rs1);                            alu.doOperation(functionBits);                            rd.copy(alu.result);                            break;                        case 3:                            // Performs operation on rs1 and rs2 (3R), then store result in rd.                            alu.op1.copy(rs1);                            alu.op2.copy(rs2);                            alu.doOperation(functionBits);                            rd.copy(alu.result);                            break;                        default:                            throw new IllegalArgumentException("Invalid format given for MATH.");                    }                }            }        }    }    private void store()    {        // This will put the result back into the registers.        if (rdIndex > 0)        {            registers[rdIndex].copy(rd);        }    }    // A simple test method to get a register to check the value.    public Word getRegisterValue(int index)    {        if (index < 0 || index >= registers.length)        {            throw new IllegalArgumentException("Register index out of bounds");        }        return new Word(registers[index]);    }}