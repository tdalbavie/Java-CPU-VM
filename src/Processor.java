public class Processor{    // Program Counter.    private Word PC = new Word();    // Stack Pointer.    private Word SP = new Word();    // Indicator for if the processor is halted.    private Bit halted = new Bit(false);    private Word currentInstruction = new Word();    // 31 registers plus 1 for the zero register.    private Word[] registers = new Word[32];    private Word rd, rs1, rs2, immediate, function;    private ALU alu = new ALU();    private int rdIndex = -1;    public Processor()    {        // Initializes other registers.        for (int i = 0; i < registers.length; i++)        {            registers[i] = new Word();            // Checks for register R0 and sets it to always be 0.            if (i == 0)            {                registers[i].set(0);            }        }        // Sets the beginning of memory (Starts at address 0).        PC.set(0);        // Sets the end of memory (Ends at address 1023 or the end of the 1024-word memory).        SP.set(1023);    }    public void run()    {        while (!halted.getValue())        {            fetch();            decode();            execute();            store();        }    }    private void fetch()    {        // Fetches instruction from memory.        currentInstruction.copy(MainMemory.read(PC));        // Increments PC to point to the next instruction.        PC.increment();    }    private void decode()    {        Word opcode = extractBits(currentInstruction, 27, 31);        // Resets or initialize words for storing extracted values.        rs1 = new Word();        rs2 = new Word();        rd = new Word();        immediate = new Word();        function = new Word();        rdIndex = -1;        int rdExtractedIndex;        int rs1Index;        int rs2Index;        // Checks the fourth bit of the opcode for 0.        if (opcode.getBit(30).getValue() == false)        {            // Checks the fifth bit of the opcode for 0.            if (opcode.getBit(31).getValue() == false)            {                // No R (0R).                immediate = extractBits(currentInstruction, 0, 26);            }            // Otherwise the fifth bit is 1.            else            {                // Dest Only (1R).                immediate = extractBits(currentInstruction, 0, 17);                function = extractBits(currentInstruction, 18, 21);                // Gets the index of the register.                rdExtractedIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();                // Uses the index to set rd to a copy of the destination register.                rd.copy(registers[rdExtractedIndex]);                rdIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();            }        }        // Otherwise the fourth bit is 1.        else        {            // Checks the fifth bit for 0.            if (opcode.getBit(31).getValue() == false)            {                // 3 Register (3R).                immediate = extractBits(currentInstruction, 0, 7);                // Gets the index of the register.                rs1Index = (int)extractBits(currentInstruction, 8, 12).getUnsigned();                // Uses the index to set rs1 to a copy of the source register.                rs1.copy(registers[rs1Index]);                // Gets the index of the register.                rs2Index = (int)extractBits(currentInstruction, 13, 17).getUnsigned();                // Uses the index to set rs2 to a copy of the source register.                rs2.copy(registers[rs2Index]);                function = extractBits(currentInstruction, 18, 21);                // Gets the index of the register.                rdExtractedIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();                // Uses the index to set rd to a copy of the destination register.                rd.copy(registers[rdExtractedIndex]);                rdIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();            }            // Otherwise the fifth bit is 1.            else            {                // 2 Register (2R).                immediate = extractBits(currentInstruction, 0, 12);                // Gets the index of the register.                rs1Index = (int)extractBits(currentInstruction, 13, 17).getUnsigned();                // Uses the index to set rs1 to a copy of the source register.                rs1.copy(registers[rs1Index]);                function = extractBits(currentInstruction, 18, 21);                // Gets the index of the register.                rdExtractedIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();                // Uses the index to set rd to a copy of the destination register.                rd.copy(registers[rdExtractedIndex]);                rdIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();            }        }    }    // Helper method for decode to extract a subset of bits from an instruction for register representation.    private Word extractBits(Word instruction, int startBit, int endBit)    {        Word result = new Word();        for (int i = endBit, j = 31; i >= startBit; i--, j--)        {            Bit bit = instruction.getBit(i);            result.setBit(j, bit);        }        return result;    }    private void execute()    {        // Extracts opcode as a Word with the last 5 bits right-aligned.        Word opcode = extractBits(currentInstruction, 27, 31);        // Checks the first bit of the opcode for 0.        if (opcode.getBit(27).getValue() == false)        {            // Checks the second bit for 0.            if (opcode.getBit(28).getValue() == false)            {                // Checks the third bit for 0.                if (opcode.getBit(29).getValue() == false)                {                    // This is MATH (000).                    // Prepares function bits for the ALU.                    Bit[] functionBits = new Bit[4];                    for (int i = 0; i < 4; i++)                    {                        functionBits[i] = function.getBit(28 + i);                    }                    // Checks the fourth bit for 0.                    if (opcode.getBit(30).getValue() == false)                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // Halt function.                            halted.set(true);                        }                        // Otherwise the fifth bit is 1.                        else                        {                            // Copies the immediate value into rd for storage.                            rd.copy(immediate);                        }                    }                    // Otherwise the fourth bit is 1.                    else                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // Performs operation on rs1 and rs2 (3R), then store result in rd.                            alu.op1.copy(rs1);                            alu.op2.copy(rs2);                            alu.doOperation(functionBits);                            rd.copy(alu.result);                        }                        // Otherwise the fifth bit is 1.                        else                        {                            // Performs operation on rd and rs1 (2R), then store result in rd.                            alu.op1.copy(rd);                            alu.op2.copy(rs1);                            alu.doOperation(functionBits);                            rd.copy(alu.result);                        }                    }                }                // Otherwise the third bit is 1.                else                {                    // This is Branch (001)                    // Checks the fourth bit for 0.                    if (opcode.getBit(30).getValue() == false)                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // JUMP: sets PC equal to the immediate value (0R).                            PC.copy(immediate);                        }                        // Otherwise the fifth bit is 1.                        else                        {                            // JUMP: sets PC equal to PC + imm (Dest Only).                            alu.op1.copy(PC);                            alu.op2.copy(immediate);                            alu.doOperation(additionCode());                            // Sets PC to the result of the ALU.                            PC.copy(alu.result);                        }                    }                    // Otherwise the fourth bit is 1.                    else                    {                        // Prepares function bits for the boolean operation.                        Bit[] functionBits = new Bit[4];                        for (int i = 0; i < 4; i++)                        {                            functionBits[i] = function.getBit(28 + i);                        }                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // Compares rs1 with rs2, if true, PC = PC + imm (3R).                            // If statement is true, PC remains the same.                            if (BOP(rs1, rs2, functionBits))                            {                                alu.op1.copy(PC);                                alu.op2.copy(immediate);                                alu.doOperation(additionCode());                                PC.copy(alu.result);                            }                        }                        // Otherwise the fifth bit is 1.                        else                        {                            // Compares rs1 with rd, if true, PC = PC + imm (2R).                            // If statement is true, PC remains the same.                            if (BOP(rs1, rd, functionBits))                            {                                alu.op1.copy(PC);                                alu.op2.copy(immediate);                                alu.doOperation(additionCode());                                PC.copy(alu.result);                            }                        }                    }                }            }            // Otherwise the second bit is 1.            else            {                // Checks the third bit for 0.                if (opcode.getBit(29).getValue() == false)                {                    // This is Call (010).                    // Checks the fourth bit for 0.                    if (opcode.getBit(30).getValue() == false)                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // JUMP: Stores old PC value to stack then sets PC equal to the immediate value (0R).                            SP.decrement();                            MainMemory.write(SP, PC);                            PC.copy(immediate);                        }                        // Otherwise the fifth bit is 1.                        else                        {                            // JUMP: Stores old PC value to stack then sets PC equal to rd + imm (Dest Only).                            SP.decrement();                            MainMemory.write(SP, PC);                            alu.op1.copy(rd);                            alu.op2.copy(immediate);                            alu.doOperation(additionCode());                            // Sets PC to the result of the ALU.                            PC.copy(alu.result);                        }                    }                    // Otherwise the fourth bit is 1.                    else                    {                        // Prepares function bits for the boolean operation.                        Bit[] functionBits = new Bit[4];                        for (int i = 0; i < 4; i++)                        {                            functionBits[i] = function.getBit(28 + i);                        }                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // Compares rs1 with rs2, if true, save PC into MainMemory and PC = rd + imm (3R).                            // If statement is true, PC remains the same.                            if (BOP(rs1, rs2, functionBits))                            {                                SP.decrement();                                MainMemory.write(SP, PC);                                alu.op1.copy(rd);                                alu.op2.copy(immediate);                                alu.doOperation(additionCode());                                PC.copy(alu.result);                            }                        }                        // Otherwise the fifth bit is 1.                        else                        {                            // Compares rs1 with rd, if true, save PC into MainMemory and PC = PC + imm (2R).                            // If statement is true, PC remains the same.                            if (BOP(rs1, rd, functionBits))                            {                                SP.decrement();                                MainMemory.write(SP, PC);                                alu.op1.copy(PC);                                alu.op2.copy(immediate);                                alu.doOperation(additionCode());                                PC.copy(alu.result);                            }                        }                    }                }                // Otherwise the third bit is 1                else                {                    // This is Push (011).                    // Prepares function bits for the ALU.                    Bit[] functionBits = new Bit[4];                    for (int i = 0; i < 4; i++)                    {                        functionBits[i] = function.getBit(28 + i);                    }                    // Checks the fourth bit for 0.                    if (opcode.getBit(30).getValue() == false)                    {                        // Checks the fifth bit for 1 (00 is unused).                        if (opcode.getBit(31).getValue() == true)                        {                            // Performs operation on rd and imm (Dest Only), then stores result in rd to be put in mem.                            alu.op1.copy(rd);                            alu.op2.copy(immediate);                            alu.doOperation(functionBits);                            rd.copy(alu.result);                        }                    }                    // Otherwise the fourth bit is 1.                    else                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // Performs operation on rs1 and rs2 (3R), then stores result in rd to be put in mem.                            alu.op1.copy(rs1);                            alu.op2.copy(rs2);                            alu.doOperation(functionBits);                            rd.copy(alu.result);                        }                        // Otherwise the fifth bit is 1.                        else                        {                            // Performs operation on rd and rs1 (2R), then stores result in rd to be put in mem.                            alu.op1.copy(rd);                            alu.op2.copy(rs1);                            alu.doOperation(functionBits);                            rd.copy(alu.result);                        }                    }                }            }        }        // Otherwise the first bit is 1.        else        {            // Checks the second bit for 0.            if (opcode.getBit(28).getValue() == false)            {                // Checks the third bit for 0.                if (opcode.getBit(29).getValue() == false)                {                    // This is Load (100).                    // Load does not do anything in execution, only stores into registers.                }                // Otherwise the third bit is 1.                else                {                    // This is Store (101).                    // Store does not do anything in execution, only stores into MainMemory.                }            }            // Otherwise the second bit is 1.            else            {                // Checks the third bit for 0.                if (opcode.getBit(29).getValue() == false)                {                    // This is Pop/interrupt (110).                    // Checks the fourth bit for 0.                    if (opcode.getBit(30).getValue() == false)                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // Interrupt is not being implemented.                        }                        // Otherwise the fifth bit is 1                        else                        {                            // POP does not do anything in execution, only stores into registers.                        }                    }                    // Otherwise the fourth bit is 1.                    else                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // PEEK does not do anything in execution, only stores into registers.                        }                        // Otherwise the fifth bit is 1                        else                        {                            // PEEK does not do anything in execution, only stores into registers.                        }                    }                }            }        }    }    // Does a boolean operation on two words based the boolean Opcode.    public boolean BOP(Word word1, Word word2, Bit[] operation)    {        // Checks if first bit is 0.        if (operation[0].getValue() == false)        {            // Checks if second bit is 0.            if (operation[1].getValue() == false)            {                // Checks if third bit is 0.                if (operation[2].getValue() == false)                {                    // Checks if fourth bit is 0.                    if (operation[3].getValue() == false)                    {                        // EQUALS: 0000                        // Compares each bit in each word to check if it's equal.                        for (int i = 0; i < 32; i++)                        {                            // If any difference is found, return false (no need to check the rest).                            if (word1.getBit(i).getValue() != word2.getBit(i).getValue())                            {                                return false;                            }                        }                        // Returns true if all bits match.                        return true;                    }                    // Otherwise fourth bit is 1.                    else                    {                        // NOT EQUALS: 0001                        // Same as equals but in reverse.                        for (int i = 0; i < 32; i++)                        {                            // If any difference is found, return true (no need to check the rest).                            if (word1.getBit(i).getValue() != word2.getBit(i).getValue())                            {                                return true;                            }                        }                        // Returns false if all bits match.                        return false;                    }                }                // Otherwise third bit is 1.                else                {                    // Checks if fourth bit is 0.                    if (operation[3].getValue() == false)                    {                        // LESS THAN: 0010                        // Subtracts the two values and if the result is negative, return is true.                        alu.op1.copy(word1);                        alu.op2.copy(word2);                        alu.doOperation(subtractionCode());                        // Checks if the first bit is 1, this means it's negative.                        if (alu.result.getBit(0).getValue() == true)                            return true;                        // Otherwise returns false.                        else                            return false;                    }                    // Otherwise fourth bit is 1.                    else                    {                        // GREATER THAN OR EQUAL: 0011                        // Gets the code for equals check.                        Bit[] equalsCode = new Bit[4];                        for (int i = 0; i < 4; i++)                        {                            equalsCode[i] = new Bit(false);                        }                        // Checks for equality recursively and returns it.                        boolean isEqual = BOP(word1, word2, equalsCode);                        // Subtracts the two values and if the result is negative, return is false.                        alu.op1.copy(word1);                        alu.op2.copy(word2);                        alu.doOperation(subtractionCode());                        // Checks if values are different.                        if (isEqual == false)                        {                            // Checks if the first bit is 0, this means it's positive.                            if (alu.result.getBit(0).getValue() == false)                                return true;                            // Comes back false if number is negative.                            else                                return false;                        }                        // Otherwise values are equal, which is true.                        else                            return true;                    }                }            }            // Otherwise second bit is 1.            else            {                // Checks if third bit is 0.                if (operation[2].getValue() == false)                {                    // Checks if fourth bit is 0.                    if (operation[3].getValue() == false)                    {                        // GREATER THAN: 0100                        // Gets the code for equals check.                        Bit[] equalsCode = new Bit[4];                        for (int i = 0; i < 4; i++)                        {                            equalsCode[i] = new Bit(false);                        }                        // Checks for equality recursively and returns it.                        boolean isEqual = BOP(word1, word2, equalsCode);                        // Subtracts the two values and if the result is negative, return is false.                        alu.op1.copy(word1);                        alu.op2.copy(word2);                        alu.doOperation(subtractionCode());                        // Checks if values are different.                        if (isEqual == false)                        {                            // Checks if the first bit is 0, this means it's positive.                            if (alu.result.getBit(0).getValue() == false)                                return true;                            // Comes back false if number is negative.                            else                                return false;                        }                        // Otherwise values are equal, which is false.                        else                            return false;                    }                    // Otherwise fourth bit is 1.                    else                    {                        // LESS THAN OR EQUAL: 0101                        // Subtracts the two values and if the result is negative, return is true.                        alu.op1.copy(word1);                        alu.op2.copy(word2);                        alu.doOperation(subtractionCode());                        // Checks if the first bit is 1, this means it's negative.                        if (alu.result.getBit(0).getValue() == true)                            return true;                        // Otherwise checks for equality and returns result.                        else                        {                            // Gets the code for equals check.                            Bit[] equalsCode = new Bit[4];                            for (int i = 0; i < 4; i++)                            {                                equalsCode[i] = new Bit(false);                            }                            // Checks for equality recursively and returns it.                            return BOP(word1, word2, equalsCode);                        }                    }                }            }        }        throw new IllegalArgumentException("Error: Boolean operation code invalid.");    }    private void store()    {        // Extracts opcode as a Word with the last 5 bits right-aligned.        Word opcode = extractBits(currentInstruction, 27, 31);        // Checks the first bit of the opcode for 0.        if (opcode.getBit(27).getValue() == false)        {            // Checks the second bit for 0.            if (opcode.getBit(28).getValue() == false)            {                // Checks the third bit for 0.                if (opcode.getBit(29).getValue() == false)                {                    // This is Math (000).                    // This will put the result back into the registers (Skips if R0 is attempted to be written to or if Rd is not set like for halt).                    if (rdIndex > 0)                    {                        registers[rdIndex].copy(rd);                    }                }                // Otherwise the third bit is 1.                else                {                    // This is Branch (001).                    // Branch does not store anything, execute changes value of PC.                }            }            // Otherwise the second bit is 1.            else            {                // Checks the third bit for 0.                if (opcode.getBit(29).getValue() == false)                {                    // This is Call (010).                    // Call does not store anything, execute changes value of PC and puts old PC value into MainMemory.                }                // Otherwise the third bit is 1.                else                {                    // This is Push (011).                    if (SP.getUnsigned() >= 0)                    {                        // Decrements the memory address and writes rd to it, all push operations store the same way.                        SP.decrement();                        MainMemory.write(SP, rd);                    }                }            }        }        // Otherwise the first bit is 1.        else        {            // Checks the second bit for 0.            if (opcode.getBit(28).getValue() == false)            {                // Checks the third bit for 0.                if (opcode.getBit(29).getValue() == false)                {                    // This is Load (100).                    // Checks the fourth bit for 0.                    if (opcode.getBit(30).getValue() == false)                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // Pops value off MainMemory stack and back into PC.                            PC.copy(MainMemory.read(SP));                            // Increment SP to "pop" entry off the stack unless SP is at the end.                            if (SP.getUnsigned() != 1023)                                SP.increment();                        }                        // Otherwise the fifth bit is 1                        else                        {                            // Gets data from MainMemory at location rd + imm into register rd (Dest Only).                            alu.op1.copy(rd);                            alu.op2.copy(immediate);                            alu.doOperation(additionCode());                            // Copies data to register of rd using result                            registers[rdIndex].copy(MainMemory.read(alu.result));                        }                    }                    // Otherwise the fourth bit is 1.                    else                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // Gets data from MainMemory at location rs1 + rs2 into register rd (3R).                            alu.op1.copy(rs1);                            alu.op2.copy(rs2);                            alu.doOperation(additionCode());                            // Copies data to register of rd using result                            registers[rdIndex].copy(MainMemory.read(alu.result));                        }                        // Otherwise the fifth bit is 1                        else                        {                            // Gets data from MainMemory at location rs1 + imm into register rd (2R).                            alu.op1.copy(rs1);                            alu.op2.copy(immediate);                            alu.doOperation(additionCode());                            // Copies data to register of rd using result                            registers[rdIndex].copy(MainMemory.read(alu.result));                        }                    }                }                // Otherwise the third bit is 1.                else                {                    // This is Store (101).                    // Checks the fourth bit for 0.                    if (opcode.getBit(30).getValue() == false)                    {                        // Checks the fifth bit for 1 (00 is unused).                        if (opcode.getBit(31).getValue() == true)                        {                            // Stores immediate into MainMemory at location rd (Dest Only).                            MainMemory.write(rd, immediate);                        }                    }                    // Otherwise the fourth bit is 1.                    else                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // Stores rs2 into MainMemory at location rd + rs1 (3R).                            alu.op1.copy(rd);                            alu.op2.copy(rs1);                            alu.doOperation(additionCode());                            // Uses alu result to get address and writes rs2 to MainMemory.                            MainMemory.write(alu.result, rs2);                        }                        // Otherwise the fifth bit is 1                        else                        {                            // Stores rs1 into MainMemory at location rd + imm (2R).                            alu.op1.copy(rd);                            alu.op2.copy(immediate);                            alu.doOperation(additionCode());                            // Uses alu result to get address and writes rs2 to MainMemory.                            MainMemory.write(alu.result, rs1);                        }                    }                }            }            // Otherwise the second bit is 1.            else            {                // Checks the third bit for 0.                if (opcode.getBit(29).getValue() == false)                {                    // This is Pop/interrupt (110).                    // Checks the fourth bit for 0.                    if (opcode.getBit(30).getValue() == false)                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // Interrupt is not being implemented.                        }                        // Otherwise the fifth bit is 1                        else                        {                            // POP: Stores data at the front of the stack into register rd, removes from main memory.                            registers[rdIndex].copy(MainMemory.read(SP));                            // Increment SP to "pop" entry off the stack.                            SP.increment();                        }                    }                    // Otherwise the fourth bit is 1.                    else                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // PEEK: gets data from MainMemory at location SP - (rs1 + rs2) into register rd (3R).                            // Starts with rs1 + rs2.                            alu.op1.copy(rs1);                            alu.op2.copy(rs2);                            alu.doOperation(additionCode());                            // Then goes on to sp - result.                            alu.op1.copy(SP);                            alu.op2.copy(alu.result);                            alu.doOperation(subtractionCode());                            // Copies data to register of rd using result                            registers[rdIndex].copy(MainMemory.read(alu.result));                        }                        // Otherwise the fifth bit is 1                        else                        {                            // PEEK: gets data from MainMemory at location SP - (rs1 + imm) into register rd (2R).                            // Starts with rs1 + rs2.                            alu.op1.copy(rs1);                            alu.op2.copy(immediate);                            alu.doOperation(additionCode());                            // Then goes on to sp - result.                            alu.op1.copy(SP);                            alu.op2.copy(alu.result);                            alu.doOperation(subtractionCode());                            // Copies data to register of rd using result                            registers[rdIndex].copy(MainMemory.read(alu.result));                        }                    }                }            }        }    }    // A simple test method to get a register to check the value.    public Word getRegisterValue(int index)    {        if (index < 0 || index >= registers.length)        {            throw new IllegalArgumentException("Register index out of bounds");        }        return new Word(registers[index]);    }    // Generates the ALU code for addition.    private Bit[] additionCode()    {        Bit[] additionBits = new Bit[4];        // Makes function code for addition (1110) to get address.        additionBits[0] = new Bit(true);        additionBits[1] = new Bit(true);        additionBits[2] = new Bit(true);        additionBits[3] = new Bit(false);        return additionBits;    }    // Generates the ALU code for subtraction.    private Bit[] subtractionCode()    {        Bit[] subtractionBits = new Bit[4];        // Makes function code for subtraction (1111) to get address.        for (int i = 0; i < 4; i++)        {            subtractionBits[i] = new Bit(true);        }        return subtractionBits;    }    // Only used for unit tests    public Word getPC()    {        return PC;    }    public Word getSP()    {        return SP;    }}