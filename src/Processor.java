public class Processor{    // Program Counter.    private Word PC = new Word();    // Stack Pointer.    private Word SP = new Word();    // Indicator for if the processor is halted.    private Bit halted = new Bit(false);    private Word currentInstruction = new Word();    // 31 registers plus 1 for the zero register.    private Word[] registers = new Word[32];    private Word rd, rs1, rs2, immediate, function;    private ALU alu = new ALU();    private int rdIndex = -1;    public Processor()    {        // Initializes other registers.        for (int i = 0; i < registers.length; i++)        {            registers[i] = new Word();            // Checks for register R0 and sets it to always be 0.            if (i == 0)            {                registers[i].set(0);            }        }        // Sets the beginning of memory (Starts at address 0).        PC.set(0);        // Sets the end of memory (Ends at address 1023 or the end of the 1024-word memory).        SP.set(1023);    }    public void run()    {        while (!halted.getValue())        {            fetch();            decode();            execute();            store();        }    }    private void fetch()    {        // Fetches instruction from memory.        currentInstruction.copy(MainMemory.read(PC));        // Increments PC to point to the next instruction.        PC.increment();    }    private void decode()    {        Word opcode = extractBits(currentInstruction, 27, 31);        // Resets or initialize words for storing extracted values.        rs1 = new Word();        rs2 = new Word();        rd = new Word();        immediate = new Word();        function = new Word();        rdIndex = -1;        int rdExtractedIndex;        int rs1Index;        int rs2Index;        // Checks the fourth bit of the opcode for 0.        if (opcode.getBit(30).getValue() == false)        {            // Checks the fifth bit of the opcode for 0.            if (opcode.getBit(31).getValue() == false)            {                // No R (0R).                immediate = extractBits(currentInstruction, 0, 26);            }            // Otherwise the fifth bit is 1.            else            {                // Dest Only (1R).                immediate = extractBits(currentInstruction, 0, 17);                function = extractBits(currentInstruction, 18, 21);                // Gets the index of the register.                rdExtractedIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();                // Uses the index to set rd to a copy of the destination register.                rd.copy(registers[rdExtractedIndex]);                rdIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();            }        }        // Otherwise the fourth bit is 1.        else        {            // Checks the fifth bit for 0.            if (opcode.getBit(31).getValue() == false)            {                // 3 Register (3R).                immediate = extractBits(currentInstruction, 0, 7);                // Gets the index of the register.                rs1Index = (int)extractBits(currentInstruction, 8, 12).getUnsigned();                // Uses the index to set rs1 to a copy of the source register.                rs1.copy(registers[rs1Index]);                // Gets the index of the register.                rs2Index = (int)extractBits(currentInstruction, 13, 17).getUnsigned();                // Uses the index to set rs2 to a copy of the source register.                rs2.copy(registers[rs2Index]);                function = extractBits(currentInstruction, 18, 21);                // Gets the index of the register.                rdExtractedIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();                // Uses the index to set rd to a copy of the destination register.                rd.copy(registers[rdExtractedIndex]);                rdIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();            }            // Otherwise the fifth bit is 1.            else            {                // 2 Register (2R).                immediate = extractBits(currentInstruction, 0, 12);                // Gets the index of the register.                rs1Index = (int)extractBits(currentInstruction, 13, 17).getUnsigned();                // Uses the index to set rs1 to a copy of the source register.                rs1.copy(registers[rs1Index]);                function = extractBits(currentInstruction, 18, 21);                // Gets the index of the register.                rdExtractedIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();                // Uses the index to set rd to a copy of the destination register.                rd.copy(registers[rdExtractedIndex]);                rdIndex = (int)extractBits(currentInstruction, 22, 26).getUnsigned();            }        }    }    // Helper method for decode to extract a subset of bits from an instruction for register representation.    private Word extractBits(Word instruction, int startBit, int endBit)    {        Word result = new Word();        for (int i = endBit, j = 31; i >= startBit; i--, j--)        {            Bit bit = instruction.getBit(i);            result.setBit(j, bit);        }        return result;    }    private void execute()    {        // Extracts opcode as a Word with the last 5 bits right-aligned.        Word opcode = extractBits(currentInstruction, 27, 31);        // Checks the first bit of the opcode for 0.        if (opcode.getBit(27).getValue() == false)        {            // Checks the second bit for 0.            if (opcode.getBit(28).getValue() == false)            {                // Checks the third bit for 0.                if (opcode.getBit(29).getValue() == false)                {                    // Prepares function bits for the ALU.                    Bit[] functionBits = new Bit[4];                    for (int i = 0; i < 4; i++)                    {                        functionBits[i] = function.getBit(28 + i);                    }                    // Checks the fourth bit for 0.                    if (opcode.getBit(30).getValue() == false)                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // Half function.                            halted.set(true);                            return;                        }                        // Otherwise the fifth bit is 1.                        else                        {                            // Copies the immediate value into rd for storage.                            rd.copy(immediate);                        }                    }                    // Otherwise the fourth bit is 1.                    else                    {                        // Checks the fifth bit for 0.                        if (opcode.getBit(31).getValue() == false)                        {                            // Performs operation on rs1 and rs2 (3R), then store result in rd.                            alu.op1.copy(rs1);                            alu.op2.copy(rs2);                            alu.doOperation(functionBits);                            rd.copy(alu.result);                        }                        // Otherwise the fifth bit is 1.                        else                        {                            // Performs operation on rd and rs1 (2R), then store result in rd.                            alu.op1.copy(rd);                            alu.op2.copy(rs1);                            alu.doOperation(functionBits);                            rd.copy(alu.result);                        }                    }                }            }        }    }    private void store()    {        // This will put the result back into the registers (Skips if R0 is attempted to be written to).        if (rdIndex > 0)        {            registers[rdIndex].copy(rd);        }    }    // A simple test method to get a register to check the value.    public Word getRegisterValue(int index)    {        if (index < 0 || index >= registers.length)        {            throw new IllegalArgumentException("Register index out of bounds");        }        return new Word(registers[index]);    }}